# チェック依頼
このGASのコードを、プロのセキュリティエンジニアの視点でレビューしてください。
ユーザーが想定外の操作（不正な値の入力、連続クリック、権限のないアクセスなど）をした場合に、システムがクラッシュしたりデータが破損したりする箇所はありますか？エラーが発生した際、ユーザーにシステム内部の情報（スタックトレースや変数名など）が露出してしまうリスクはありますか？
セキュリティ上、脆弱な書き方をしている箇所を特定し、その理由と修正案を提示してください。

# 返答
[2 tools called]

以下は**プロのセキュリティエンジニア視点のレビュー**です。  
指摘は**重大度順**で並べ、理由と修正案を示します。

---

## 重大

### 1) 認可（権限）チェックが無い
**現状**  
`apiGetQuestionDetail` や `saveQuestion` は、スプレッドシートにアクセスできるユーザーなら誰でも実行できます。  
内部ロールや権限制御が無いので、**編集権限を持つユーザーが不正入力でデータを改ざん可能**です。

```98:170:code.gs
function apiGetQuestionDetail(qid) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheetQ = getSheetByNameFlexible_(ss, SHEET_Q);
    const sheetC = getSheetByNameFlexible_(ss, SHEET_C);
    ...
```

**リスク**  
- 設問や選択肢の不正な改ざん
- 大量書き込みによるデータ破損・DoS的挙動

**修正案**  
- `Session.getActiveUser().getEmail()` で許可ユーザーのみ許可  
- 管理者メールのホワイトリストを設ける  
- 少なくとも「閲覧のみ/編集のみ」などの簡易ガードを入れる

---

### 2) スプレッドシートに式を注入できる（Formula Injection）
**現状**  
`saveQuestion` で入力値を**そのままセルに保存**しています。  
`=IMPORTDATA(...)` のような式をユーザーが入力すると、**シートを開いた別ユーザーで外部通信やデータ漏洩が起きる可能性**があります。

```175:286:code.gs
const rowDataQ = [
  qkey,
  payload.qid || "",
  ...
  payload.question || "",
  payload.instruction || "",
  ...
];
...
sheetQ.appendRow(rowDataQ);
```

**リスク**  
- 外部へのデータ漏洩  
- スプレッドシート内の任意計算/フィッシングに悪用

**修正案**  
- **式として解釈される文字列 (`=`, `+`, `-`, `@`) を無効化**  
  例: 先頭に `'` を付与して文字列化  
- すべてのユーザー入力値に対してサニタイズを行う

---

### 3) 競合時に `qkey` が重複する可能性（データ破損）
**現状**  
`qkey` を採番する際に**ロックが無い**ため、同時保存で重複する可能性があります。

```183:197:code.gs
if (isNew) {
  const lastRowQ = sheetQ.getLastRow();
  let maxNum = 0;
  ...
  qkey = QKEY_PREFIX + String(maxNum + 1).padStart(QKEY_DIGITS, '0');
}
```

**リスク**  
- 同一 `qkey` が複数行に発生  
- 以降の更新・削除が壊れる  

**修正案**  
- `LockService.getScriptLock()` を使い**排他制御**  
- 保存処理全体をロック内に入れる  

---

## 中

### 4) 内部情報の露出（シート名・構成）
**現状**  
例外メッセージに**実際のシート名一覧**を含めて返却しています。

```44:58:code.gs
throw new Error(`シート "${name}" が見つかりません。存在するシート名: ${sheets.map(s => s.getName()).join(", ")}`);
```

**リスク**  
- シート構成・命名が露出し、運用情報が漏れる

**修正案**  
- ユーザー向けメッセージは簡略化  
  例: 「必要なシートが見つかりません。管理者に連絡してください」  
- 詳細はログ（`Logger.log`）にのみ出す  

---

### 5) デバッグ機能が本番に残っている
**現状**  
`debugLookup()` が存在し、**ヘッダーやサンプルQIDがクライアントに出力**されます。  
さらに `sidebar.html` は `debug` に詳細ログを表示します。

```296:336:code.gs
function debugLookup(qid) { ... return { headersQ, headersC, sampleQids, ... }; }
```

```98:205:sidebar.html
logDebug("debug: " + JSON.stringify(info));
```

**リスク**  
- 構造情報がユーザーに露出  
- 本番環境での情報漏洩に繋がる

**修正案**  
- `debugLookup` と `debug` 表示は削除  
- もしくは管理者のみ有効化するガードを入れる

---

## 低

### 6) 入力値の検証不足（型・範囲）
**現状**  
`order` や `q_level` の範囲チェックが無く、不正値が入っても保存されます。

```213:229:code.gs
Number(payload.q_level) || 2,
Number(payload.order) || 0,
```

**リスク**  
- データ整合性の崩壊  
- 予期しない並び順・集計崩れ

**修正案**  
- `q_level` は 1〜3 のみ許可  
- `order` は 0 以上の整数のみ許可  
- バリデーション失敗時は保存拒否

---

## クラッシュ／データ破損の観点
- **連打・同時保存** → `qkey` 重複（上記重大3）  
- **不正値入力** → 入力検証無しで保存される  
- **権限外アクセス** → Apps Script 権限内なら無制限に書き込み可能  

---

## 結論
- **最大のセキュリティリスクは「認可が無い」ことと「式注入」**です。  
- デバッグ機能と詳細エラー露出も、**運用フェーズでは必ず除去**すべきです。

---

必要なら、上記の**修正パッチ（権限チェック・式注入対策・ロック・バリデーション）**を具体的に実装します。  
どこまで厳格にするか（管理者のみ/編集者のみ/閲覧者のみ）だけ教えてください。

# 対応
- レビュー指摘1への対応：code.gs に、許可されたユーザー（自分や特定の社員のメールアドレス）以外は saveQuestion などの書き込み処理を実行できないようにするガードレール関数を追加して、各API関数の冒頭で呼び出すように修正してください。

以下が追加したガードレールの内容と動作です。

---

## 追加した内容
### 1) 許可ユーザーのリスト
```code
const ALLOWED_WRITE_EMAILS = [
  // 例: "you@example.com",
];
```
ここに **書き込みを許可するメールアドレス**を列挙します。

---

### 2) 権限チェック関数
```code
function assertAuthorizedWrite_() {
  const email = Session.getActiveUser().getEmail();
  if (!email || ALLOWED_WRITE_EMAILS.indexOf(email) === -1) {
    throw new Error("この操作を実行する権限がありません。");
  }
}
```
- 実行ユーザーのメールを取得  
- 許可リストにない場合は **例外を投げて処理を中断**  
- 例外はサイドバー側にエラーとして返ります  

---

### 3) 書き込み系APIの先頭で呼び出し
```code
function saveQuestion(payload) {
  assertAuthorizedWrite_();
  ...
}

function exportMdYamlToDrive() {
  assertAuthorizedWrite_();
  ...
}
```
これにより **許可ユーザー以外は保存・書き出しできない**状態になります。

---

## 注意点
- `Session.getActiveUser().getEmail()` は  
  **ドメイン制限や実行環境により空文字になる場合**があります。  
  その場合は常に拒否されます。  
- その場合は `Session.getEffectiveUser().getEmail()` に切り替えるか、  
  同一ドメイン内での運用を前提にする必要があります。

---

必要なら、**読み取り系（`apiGetQuestionDetail`）は許可/拒否のどちらにするか**も方針を決めてガードを追加できます。

# 修正への解説

以下が追加したガードレールの内容と動作です。

---

## 追加した内容
### 1) 許可ユーザーのリスト
```code
const ALLOWED_WRITE_EMAILS = [
  // 例: "you@example.com",
];
```
ここに **書き込みを許可するメールアドレス**を列挙します。

---

### 2) 権限チェック関数
```code
function assertAuthorizedWrite_() {
  const email = Session.getActiveUser().getEmail();
  if (!email || ALLOWED_WRITE_EMAILS.indexOf(email) === -1) {
    throw new Error("この操作を実行する権限がありません。");
  }
}
```
- 実行ユーザーのメールを取得  
- 許可リストにない場合は **例外を投げて処理を中断**  
- 例外はサイドバー側にエラーとして返ります  

---

### 3) 書き込み系APIの先頭で呼び出し
```code
function saveQuestion(payload) {
  assertAuthorizedWrite_();
  ...
}

function exportMdYamlToDrive() {
  assertAuthorizedWrite_();
  ...
}
```
これにより **許可ユーザー以外は保存・書き出しできない**状態になります。

---

## 注意点
- `Session.getActiveUser().getEmail()` は  
  **ドメイン制限や実行環境により空文字になる場合**があります。  
  その場合は常に拒否されます。  
- その場合は `Session.getEffectiveUser().getEmail()` に切り替えるか、  
  同一ドメイン内での運用を前提にする必要があります。

---

必要なら、**読み取り系（`apiGetQuestionDetail`）は許可/拒否のどちらにするか**も方針を決めてガードを追加できます。

# 対応依頼
- レビュー指摘3への対応：GASの LockService.getScriptLock() を使い、saveQuestion の処理開始から終了までを排他制御するように修正してください。ロックが取得できなかった場合のタイムアウト処理も含めてください。

# 対応

[1 tool called]

`saveQuestion` を **LockService で排他制御**するよう修正しました。  
取得失敗時はタイムアウトエラーを返すようにしています。

### 反映内容
- `SAVE_LOCK_TIMEOUT_MS` を追加（10秒）
- `saveQuestion` 冒頭で `waitLock` を実行
- 取得失敗時はユーザー向けエラーを返す
- `finally` で確実に `releaseLock` を実行

---

必要なら **タイムアウト時間の変更** や **保存以外（例: export）にもロック適用** も対応します。

